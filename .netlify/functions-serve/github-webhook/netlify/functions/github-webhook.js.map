{
  "version": 3,
  "sources": ["../../../../OneDrive/Documents/GitHub/Beehive/netlify/functions/github-webhook.ts", "../../../../OneDrive/Documents/GitHub/Beehive/packages/webhook-gateway/src/dispatcher.ts", "../../../../OneDrive/Documents/GitHub/Beehive/packages/webhook-gateway/src/router.ts", "../../../../OneDrive/Documents/GitHub/Beehive/node_modules/@netlify/runtime-utils/dist/main.js", "../../../../OneDrive/Documents/GitHub/Beehive/node_modules/@netlify/blobs/dist/chunk-HN33TXZT.js", "../../../../OneDrive/Documents/GitHub/Beehive/node_modules/@netlify/otel/dist/main.js", "../../../../OneDrive/Documents/GitHub/Beehive/node_modules/@netlify/blobs/dist/main.js", "../../../../OneDrive/Documents/GitHub/Beehive/packages/webhook-gateway/src/telemetry.ts"],
  "sourceRoot": "C:/Users/north/AppData/Local/Temp/tmp-18540-QpOS0aEafLkk",
  "sourcesContent": ["import type { Handler } from '@netlify/functions';\r\nimport { createHmac, timingSafeEqual } from 'crypto';\r\nimport { EventRouter } from '../../packages/webhook-gateway/src/router';\r\nimport { TelemetryLogger } from '../../packages/webhook-gateway/src/telemetry';\r\n\r\nconst WEBHOOK_SECRET = process.env.GITHUB_WEBHOOK_SECRET!;\r\nconst ENABLE_WEBHOOK_PROCESSING = process.env.ENABLE_WEBHOOK_PROCESSING === 'true';\r\n\r\nexport const handler: Handler = async (event) => {\r\n  const startTime = Date.now();\r\n  const telemetry = new TelemetryLogger();\r\n  try {\r\n    if (event.httpMethod !== 'POST') {\r\n      return { statusCode: 405, body: JSON.stringify({ error: 'Method not allowed' }) };\r\n    }\r\n\r\n    const headers = event.headers as Record<string, string>;\r\n    const githubEvent = headers['x-github-event'] || headers['X-GitHub-Event'];\r\n    const deliveryId = headers['x-github-delivery'] || headers['X-GitHub-Delivery'];\r\n    const signature = headers['x-hub-signature-256'] || headers['X-Hub-Signature-256'];\r\n\r\n    if (!githubEvent || !deliveryId || !signature) {\r\n      return { statusCode: 400, body: JSON.stringify({ error: 'Missing required headers' }) };\r\n    }\r\n\r\n    const payload = event.body ?? '';\r\n    if (!verifySignature(payload, signature)) {\r\n      telemetry.log('security', 'webhook_signature_invalid', { deliveryId, event: githubEvent });\r\n      return { statusCode: 401, body: JSON.stringify({ error: 'Invalid signature' }) };\r\n    }\r\n\r\n    const data = payload ? JSON.parse(payload) : {};\r\n\r\n    telemetry.log('webhook', 'received', {\r\n      event: githubEvent,\r\n      deliveryId,\r\n      action: data.action || 'none',\r\n      repository: data.repository?.full_name,\r\n      sender: data.sender?.login\r\n    });\r\n\r\n    if (!ENABLE_WEBHOOK_PROCESSING) {\r\n      telemetry.log('webhook', 'processing_disabled', { deliveryId });\r\n      return {\r\n        statusCode: 200,\r\n        body: JSON.stringify({ received: true, processed: false, reason: 'Processing disabled' })\r\n      };\r\n    }\r\n\r\n    const router = new EventRouter(telemetry);\r\n    const result = await router.route(githubEvent, data);\r\n\r\n    const duration = Date.now() - startTime;\r\n    telemetry.log('performance', 'webhook_processed', { deliveryId, duration, success: result.success });\r\n\r\n    return {\r\n      statusCode: 200,\r\n      body: JSON.stringify({ received: true, processed: true, deliveryId, taskId: result.taskId, duration })\r\n    };\r\n  } catch (error: any) {\r\n    const duration = Date.now() - startTime;\r\n    telemetry.log('error', 'webhook_processing_failed', { error: error.message, stack: error.stack, duration });\r\n    return { statusCode: 500, body: JSON.stringify({ error: 'Webhook processing failed', message: error.message }) };\r\n  }\r\n};\r\n\r\nfunction verifySignature(payload: string, signature: string): boolean {\r\n  if (!WEBHOOK_SECRET) return false;\r\n  const hmac = createHmac('sha256', WEBHOOK_SECRET);\r\n  const digest = 'sha256=' + hmac.update(payload).digest('hex');\r\n  try {\r\n    return timingSafeEqual(Buffer.from(signature), Buffer.from(digest));\r\n  } catch {\r\n    return false;\r\n  }\r\n}\r\n", "import { TelemetryLogger } from './telemetry';\r\n\r\nexport interface SwarmTask {\r\n  type: string;\r\n  priority: 'urgent' | 'high' | 'normal' | 'low';\r\n  context: Record<string, any>;\r\n}\r\n\r\nexport interface DispatchResult {\r\n  success: boolean;\r\n  taskId?: string;\r\n  reason?: string;\r\n}\r\n\r\nexport class SwarmDispatcher {\r\n  private telemetry: TelemetryLogger;\r\n  private taskQueue: SwarmTask[] = [];\r\n\r\n  constructor(telemetry: TelemetryLogger) {\r\n    this.telemetry = telemetry;\r\n  }\r\n\r\n  async dispatch(task: SwarmTask): Promise<DispatchResult> {\r\n    const taskId = this.generateTaskId();\r\n    this.telemetry.log('dispatcher', 'task_created', { taskId, type: task.type, priority: task.priority, context: task.context });\r\n    this.taskQueue.push(task);\r\n    this.telemetry.log('dispatcher', 'task_queued', { taskId, queueLength: this.taskQueue.length });\r\n    return { success: true, taskId };\r\n  }\r\n\r\n  private generateTaskId(): string {\r\n    return `task_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\r\n  }\r\n\r\n  getQueueStatus() {\r\n    return { length: this.taskQueue.length, tasks: this.taskQueue.map(t => ({ type: t.type, priority: t.priority })) };\r\n  }\r\n}\r\n\r\n", "import { SwarmDispatcher } from './dispatcher';\r\nimport { TelemetryLogger } from './telemetry';\r\n\r\nexport interface RoutingResult {\r\n  success: boolean;\r\n  taskId?: string;\r\n  reason?: string;\r\n}\r\n\r\nexport class EventRouter {\r\n  private dispatcher: SwarmDispatcher;\r\n  private telemetry: TelemetryLogger;\r\n\r\n  constructor(telemetry: TelemetryLogger) {\r\n    this.telemetry = telemetry;\r\n    this.dispatcher = new SwarmDispatcher(telemetry);\r\n  }\r\n\r\n  async route(eventType: string, payload: any): Promise<RoutingResult> {\r\n    this.telemetry.log('router', 'routing_event', { eventType, action: payload?.action });\r\n\r\n    switch (eventType) {\r\n      case 'push':\r\n        return this.handlePush(payload);\r\n      case 'pull_request':\r\n        return this.handlePullRequest(payload);\r\n      case 'pull_request_review':\r\n        return this.handlePullRequestReview(payload);\r\n      case 'workflow_run':\r\n        return this.handleWorkflowRun(payload);\r\n      case 'issues':\r\n        return this.handleIssue(payload);\r\n      case 'issue_comment':\r\n        return this.handleIssueComment(payload);\r\n      default:\r\n        this.telemetry.log('router', 'event_ignored', { eventType, reason: 'No handler registered' });\r\n        return { success: true, reason: `Event type '${eventType}' not handled` };\r\n    }\r\n  }\r\n\r\n  private async handlePush(payload: any): Promise<RoutingResult> {\r\n    const { ref, repository, commits, pusher } = payload || {};\r\n    const branch = typeof ref === 'string' ? ref.replace('refs/heads/', '') : '';\r\n\r\n    if (branch !== 'main' && branch !== 'master') {\r\n      return { success: true, reason: 'Non-main branch push ignored' };\r\n    }\r\n\r\n    const modifiedFiles = (commits || []).flatMap((c: any) => [\r\n      ...(c?.added || []),\r\n      ...(c?.modified || []),\r\n      ...(c?.removed || []),\r\n    ]);\r\n\r\n    const task = {\r\n      type: 'code_push_analysis',\r\n      priority: 'normal' as const,\r\n      context: { repository: repository?.full_name, branch, commits: (commits || []).length, files: modifiedFiles, pusher: pusher?.name }\r\n    };\r\n\r\n    return this.dispatcher.dispatch(task);\r\n  }\r\n\r\n  private async handlePullRequest(payload: any): Promise<RoutingResult> {\r\n    const { action, pull_request, repository } = payload || {};\r\n\r\n    if (!['opened', 'synchronize', 'reopened'].includes(action)) {\r\n      return { success: true, reason: `PR action '${action}' not analyzed` };\r\n    }\r\n\r\n    const task = {\r\n      type: 'pr_analysis',\r\n      priority: 'high' as const,\r\n      context: {\r\n        repository: repository?.full_name,\r\n        prNumber: pull_request?.number,\r\n        title: pull_request?.title,\r\n        author: pull_request?.user?.login,\r\n        baseRef: pull_request?.base?.ref,\r\n        headRef: pull_request?.head?.ref,\r\n        changedFiles: pull_request?.changed_files,\r\n        additions: pull_request?.additions,\r\n        deletions: pull_request?.deletions\r\n      }\r\n    };\r\n\r\n    return this.dispatcher.dispatch(task);\r\n  }\r\n\r\n  private async handlePullRequestReview(payload: any): Promise<RoutingResult> {\r\n    const { action, review, pull_request, repository } = payload || {};\r\n    if (action !== 'submitted' || (review?.state === 'approved' && !review?.body)) {\r\n      return { success: true, reason: 'Review not analyzed' };\r\n    }\r\n\r\n    const task = {\r\n      type: 'review_analysis',\r\n      priority: 'normal' as const,\r\n      context: { repository: repository?.full_name, prNumber: pull_request?.number, reviewer: review?.user?.login, state: review?.state, body: review?.body }\r\n    };\r\n\r\n    return this.dispatcher.dispatch(task);\r\n  }\r\n\r\n  private async handleWorkflowRun(payload: any): Promise<RoutingResult> {\r\n    const { workflow_run, repository } = payload || {};\r\n    if (workflow_run?.conclusion !== 'failure') {\r\n      return { success: true, reason: 'Workflow did not fail' };\r\n    }\r\n\r\n    const task = {\r\n      type: 'workflow_failure_analysis',\r\n      priority: 'urgent' as const,\r\n      context: { repository: repository?.full_name, workflowName: workflow_run?.name, runId: workflow_run?.id, headBranch: workflow_run?.head_branch, conclusion: workflow_run?.conclusion, url: workflow_run?.html_url }\r\n    };\r\n\r\n    return this.dispatcher.dispatch(task);\r\n  }\r\n\r\n  private async handleIssue(payload: any): Promise<RoutingResult> {\r\n    const { action, issue, repository } = payload || {};\r\n    if (action !== 'opened') return { success: true, reason: 'Issue not opened' };\r\n\r\n    const labels = (issue?.labels || []).map((l: any) => (typeof l === 'string' ? l : l?.name));\r\n    if (!labels.some((l: string) => ['bug', 'enhancement', 'feature'].includes((l || '').toLowerCase()))) {\r\n      return { success: true, reason: 'Issue not labeled for analysis' };\r\n    }\r\n\r\n    const task = {\r\n      type: 'issue_triage',\r\n      priority: 'normal' as const,\r\n      context: { repository: repository?.full_name, issueNumber: issue?.number, title: issue?.title, body: issue?.body, labels, author: issue?.user?.login }\r\n    };\r\n\r\n    return this.dispatcher.dispatch(task);\r\n  }\r\n\r\n  private async handleIssueComment(payload: any): Promise<RoutingResult> {\r\n    const { action, comment, issue, repository } = payload || {};\r\n    if (action !== 'created' || !comment?.body?.includes?.('@adgenai-bot')) {\r\n      return { success: true, reason: 'Bot not mentioned' };\r\n    }\r\n\r\n    const task = {\r\n      type: 'comment_response',\r\n      priority: 'high' as const,\r\n      context: { repository: repository?.full_name, issueNumber: issue?.number, commentId: comment?.id, body: comment?.body, author: comment?.user?.login }\r\n    };\r\n\r\n    return this.dispatcher.dispatch(task);\r\n  }\r\n}\r\n\r\n", "// src/lib/base64.ts\nvar getString = (input) => typeof input === \"string\" ? input : JSON.stringify(input);\nvar base64Decode = globalThis.Buffer ? (input) => Buffer.from(input, \"base64\").toString() : (input) => atob(input);\nvar base64Encode = globalThis.Buffer ? (input) => Buffer.from(getString(input)).toString(\"base64\") : (input) => btoa(getString(input));\nexport {\n  base64Decode,\n  base64Encode\n};\n", "// src/environment.ts\nimport { base64Decode, base64Encode } from \"@netlify/runtime-utils\";\nvar getEnvironment = () => {\n  const { Deno, Netlify, process: process2 } = globalThis;\n  return Netlify?.env ?? Deno?.env ?? {\n    delete: (key) => delete process2?.env[key],\n    get: (key) => process2?.env[key],\n    has: (key) => Boolean(process2?.env[key]),\n    set: (key, value) => {\n      if (process2?.env) {\n        process2.env[key] = value;\n      }\n    },\n    toObject: () => process2?.env ?? {}\n  };\n};\nvar getEnvironmentContext = () => {\n  const context = globalThis.netlifyBlobsContext || getEnvironment().get(\"NETLIFY_BLOBS_CONTEXT\");\n  if (typeof context !== \"string\" || !context) {\n    return {};\n  }\n  const data = base64Decode(context);\n  try {\n    return JSON.parse(data);\n  } catch {\n  }\n  return {};\n};\nvar setEnvironmentContext = (context) => {\n  const encodedContext = base64Encode(JSON.stringify(context));\n  getEnvironment().set(\"NETLIFY_BLOBS_CONTEXT\", encodedContext);\n};\nvar MissingBlobsEnvironmentError = class extends Error {\n  constructor(requiredProperties) {\n    super(\n      `The environment has not been configured to use Netlify Blobs. To use it manually, supply the following properties when creating a store: ${requiredProperties.join(\n        \", \"\n      )}`\n    );\n    this.name = \"MissingBlobsEnvironmentError\";\n  }\n};\n\n// src/metadata.ts\nimport { base64Decode as base64Decode2, base64Encode as base64Encode2 } from \"@netlify/runtime-utils\";\nvar BASE64_PREFIX = \"b64;\";\nvar METADATA_HEADER_INTERNAL = \"x-amz-meta-user\";\nvar METADATA_HEADER_EXTERNAL = \"netlify-blobs-metadata\";\nvar METADATA_MAX_SIZE = 2 * 1024;\nvar encodeMetadata = (metadata) => {\n  if (!metadata) {\n    return null;\n  }\n  const encodedObject = base64Encode2(JSON.stringify(metadata));\n  const payload = `b64;${encodedObject}`;\n  if (METADATA_HEADER_EXTERNAL.length + payload.length > METADATA_MAX_SIZE) {\n    throw new Error(\"Metadata object exceeds the maximum size\");\n  }\n  return payload;\n};\nvar decodeMetadata = (header) => {\n  if (!header?.startsWith(BASE64_PREFIX)) {\n    return {};\n  }\n  const encodedData = header.slice(BASE64_PREFIX.length);\n  const decodedData = base64Decode2(encodedData);\n  const metadata = JSON.parse(decodedData);\n  return metadata;\n};\nvar getMetadataFromResponse = (response) => {\n  if (!response.headers) {\n    return {};\n  }\n  const value = response.headers.get(METADATA_HEADER_EXTERNAL) || response.headers.get(METADATA_HEADER_INTERNAL);\n  try {\n    return decodeMetadata(value);\n  } catch {\n    throw new Error(\n      \"An internal error occurred while trying to retrieve the metadata for an entry. Please try updating to the latest version of the Netlify Blobs client.\"\n    );\n  }\n};\n\n// src/util.ts\nimport process from \"process\";\n\n// src/headers.ts\nvar NF_ERROR = \"x-nf-error\";\nvar NF_REQUEST_ID = \"x-nf-request-id\";\n\n// src/util.ts\nvar BlobsInternalError = class extends Error {\n  constructor(res) {\n    let details = res.headers.get(NF_ERROR) || `${res.status} status code`;\n    if (res.headers.has(NF_REQUEST_ID)) {\n      details += `, ID: ${res.headers.get(NF_REQUEST_ID)}`;\n    }\n    super(`Netlify Blobs has generated an internal error (${details})`);\n    this.name = \"BlobsInternalError\";\n  }\n};\nvar collectIterator = async (iterator) => {\n  const result = [];\n  for await (const item of iterator) {\n    result.push(item);\n  }\n  return result;\n};\nvar isNodeError = (error) => error instanceof Error;\nfunction percentEncode(str) {\n  return str.replace(/./, (char) => {\n    return \"%\" + char.charCodeAt(0).toString(16).padStart(2, \"0\");\n  });\n}\nvar invalidWin32File = /^(CON|COM[1-9]|LPT[1-9]|NUL|PRN|AUX)$/i;\nfunction encodeWin32SafeName(string) {\n  if (invalidWin32File.exec(string)) {\n    return percentEncode(string);\n  }\n  return encodeURIComponent(string).replace(/([*]|[. ]$)/g, percentEncode);\n}\nfunction decodeWin32SafeName(string) {\n  return decodeURIComponent(string);\n}\nfunction encodeName(string) {\n  return process.platform == \"win32\" ? encodeWin32SafeName(string) : string;\n}\nfunction decodeName(string) {\n  return process.platform == \"win32\" ? decodeWin32SafeName(string) : string;\n}\n\n// src/consistency.ts\nvar BlobsConsistencyError = class extends Error {\n  constructor() {\n    super(\n      `Netlify Blobs has failed to perform a read using strong consistency because the environment has not been configured with a 'uncachedEdgeURL' property`\n    );\n    this.name = \"BlobsConsistencyError\";\n  }\n};\n\n// src/region.ts\nvar REGION_AUTO = \"auto\";\nvar regions = {\n  \"us-east-1\": true,\n  \"us-east-2\": true,\n  \"eu-central-1\": true,\n  \"ap-southeast-1\": true,\n  \"ap-southeast-2\": true\n};\nvar isValidRegion = (input) => Object.keys(regions).includes(input);\nvar InvalidBlobsRegionError = class extends Error {\n  constructor(region) {\n    super(\n      `${region} is not a supported Netlify Blobs region. Supported values are: ${Object.keys(regions).join(\", \")}.`\n    );\n    this.name = \"InvalidBlobsRegionError\";\n  }\n};\n\n// src/retry.ts\nvar DEFAULT_RETRY_DELAY = getEnvironment().get(\"NODE_ENV\") === \"test\" ? 1 : 5e3;\nvar MIN_RETRY_DELAY = 1e3;\nvar MAX_RETRY = 5;\nvar RATE_LIMIT_HEADER = \"X-RateLimit-Reset\";\nvar fetchAndRetry = async (fetch, url, options, attemptsLeft = MAX_RETRY) => {\n  try {\n    const res = await fetch(url, options);\n    if (attemptsLeft > 0 && (res.status === 429 || res.status >= 500)) {\n      const delay = getDelay(res.headers.get(RATE_LIMIT_HEADER));\n      await sleep(delay);\n      return fetchAndRetry(fetch, url, options, attemptsLeft - 1);\n    }\n    return res;\n  } catch (error) {\n    if (attemptsLeft === 0) {\n      throw error;\n    }\n    const delay = getDelay();\n    await sleep(delay);\n    return fetchAndRetry(fetch, url, options, attemptsLeft - 1);\n  }\n};\nvar getDelay = (rateLimitReset) => {\n  if (!rateLimitReset) {\n    return DEFAULT_RETRY_DELAY;\n  }\n  return Math.max(Number(rateLimitReset) * 1e3 - Date.now(), MIN_RETRY_DELAY);\n};\nvar sleep = (ms) => new Promise((resolve) => {\n  setTimeout(resolve, ms);\n});\n\n// src/client.ts\nvar SIGNED_URL_ACCEPT_HEADER = \"application/json;type=signed-url\";\nvar Client = class {\n  constructor({ apiURL, consistency, edgeURL, fetch, region, siteID, token, uncachedEdgeURL }) {\n    this.apiURL = apiURL;\n    this.consistency = consistency ?? \"eventual\";\n    this.edgeURL = edgeURL;\n    this.fetch = fetch ?? globalThis.fetch;\n    this.region = region;\n    this.siteID = siteID;\n    this.token = token;\n    this.uncachedEdgeURL = uncachedEdgeURL;\n    if (!this.fetch) {\n      throw new Error(\n        \"Netlify Blobs could not find a `fetch` client in the global scope. You can either update your runtime to a version that includes `fetch` (like Node.js 18.0.0 or above), or you can supply your own implementation using the `fetch` property.\"\n      );\n    }\n  }\n  async getFinalRequest({\n    consistency: opConsistency,\n    key,\n    metadata,\n    method,\n    parameters = {},\n    storeName\n  }) {\n    const encodedMetadata = encodeMetadata(metadata);\n    const consistency = opConsistency ?? this.consistency;\n    let urlPath = `/${this.siteID}`;\n    if (storeName) {\n      urlPath += `/${storeName}`;\n    }\n    if (key) {\n      urlPath += `/${key}`;\n    }\n    if (this.edgeURL) {\n      if (consistency === \"strong\" && !this.uncachedEdgeURL) {\n        throw new BlobsConsistencyError();\n      }\n      const headers = {\n        authorization: `Bearer ${this.token}`\n      };\n      if (encodedMetadata) {\n        headers[METADATA_HEADER_INTERNAL] = encodedMetadata;\n      }\n      if (this.region) {\n        urlPath = `/region:${this.region}${urlPath}`;\n      }\n      const url2 = new URL(urlPath, consistency === \"strong\" ? this.uncachedEdgeURL : this.edgeURL);\n      for (const key2 in parameters) {\n        url2.searchParams.set(key2, parameters[key2]);\n      }\n      return {\n        headers,\n        url: url2.toString()\n      };\n    }\n    const apiHeaders = { authorization: `Bearer ${this.token}` };\n    const url = new URL(`/api/v1/blobs${urlPath}`, this.apiURL ?? \"https://api.netlify.com\");\n    for (const key2 in parameters) {\n      url.searchParams.set(key2, parameters[key2]);\n    }\n    if (this.region) {\n      url.searchParams.set(\"region\", this.region);\n    }\n    if (storeName === void 0 || key === void 0) {\n      return {\n        headers: apiHeaders,\n        url: url.toString()\n      };\n    }\n    if (encodedMetadata) {\n      apiHeaders[METADATA_HEADER_EXTERNAL] = encodedMetadata;\n    }\n    if (method === \"head\" /* HEAD */ || method === \"delete\" /* DELETE */) {\n      return {\n        headers: apiHeaders,\n        url: url.toString()\n      };\n    }\n    const res = await this.fetch(url.toString(), {\n      headers: { ...apiHeaders, accept: SIGNED_URL_ACCEPT_HEADER },\n      method\n    });\n    if (res.status !== 200) {\n      throw new BlobsInternalError(res);\n    }\n    const { url: signedURL } = await res.json();\n    const userHeaders = encodedMetadata ? { [METADATA_HEADER_INTERNAL]: encodedMetadata } : void 0;\n    return {\n      headers: userHeaders,\n      url: signedURL\n    };\n  }\n  async makeRequest({\n    body,\n    conditions = {},\n    consistency,\n    headers: extraHeaders,\n    key,\n    metadata,\n    method,\n    parameters,\n    storeName\n  }) {\n    const { headers: baseHeaders = {}, url } = await this.getFinalRequest({\n      consistency,\n      key,\n      metadata,\n      method,\n      parameters,\n      storeName\n    });\n    const headers = {\n      ...baseHeaders,\n      ...extraHeaders\n    };\n    if (method === \"put\" /* PUT */) {\n      headers[\"cache-control\"] = \"max-age=0, stale-while-revalidate=60\";\n    }\n    if (\"onlyIfMatch\" in conditions && conditions.onlyIfMatch) {\n      headers[\"if-match\"] = conditions.onlyIfMatch;\n    } else if (\"onlyIfNew\" in conditions && conditions.onlyIfNew) {\n      headers[\"if-none-match\"] = \"*\";\n    }\n    const options = {\n      body,\n      headers,\n      method\n    };\n    if (body instanceof ReadableStream) {\n      options.duplex = \"half\";\n    }\n    return fetchAndRetry(this.fetch, url, options);\n  }\n};\nvar getClientOptions = (options, contextOverride) => {\n  const context = contextOverride ?? getEnvironmentContext();\n  const siteID = context.siteID ?? options.siteID;\n  const token = context.token ?? options.token;\n  if (!siteID || !token) {\n    throw new MissingBlobsEnvironmentError([\"siteID\", \"token\"]);\n  }\n  if (options.region !== void 0 && !isValidRegion(options.region)) {\n    throw new InvalidBlobsRegionError(options.region);\n  }\n  const clientOptions = {\n    apiURL: context.apiURL ?? options.apiURL,\n    consistency: options.consistency,\n    edgeURL: context.edgeURL ?? options.edgeURL,\n    fetch: options.fetch,\n    region: options.region,\n    siteID,\n    token,\n    uncachedEdgeURL: context.uncachedEdgeURL ?? options.uncachedEdgeURL\n  };\n  return clientOptions;\n};\n\nexport {\n  getEnvironmentContext,\n  setEnvironmentContext,\n  MissingBlobsEnvironmentError,\n  METADATA_HEADER_INTERNAL,\n  encodeMetadata,\n  decodeMetadata,\n  getMetadataFromResponse,\n  REGION_AUTO,\n  BlobsInternalError,\n  collectIterator,\n  isNodeError,\n  encodeName,\n  decodeName,\n  SIGNED_URL_ACCEPT_HEADER,\n  Client,\n  getClientOptions\n};\n", "// src/constants.ts\nvar GET_TRACER = \"__netlify__getTracer\";\nvar SHUTDOWN_TRACERS = \"__netlify__shutdownTracers\";\n\n// src/main.ts\nvar getTracer = (name, version) => {\n  return globalThis[GET_TRACER]?.(name, version);\n};\nvar shutdownTracers = async () => {\n  return globalThis[SHUTDOWN_TRACERS]?.();\n};\nfunction withActiveSpan(tracer, name, optionsOrFn, contextOrFn, fn) {\n  const func = typeof contextOrFn === \"function\" ? contextOrFn : typeof optionsOrFn === \"function\" ? optionsOrFn : fn;\n  if (!func) {\n    throw new Error(\"function to execute with active span is missing\");\n  }\n  if (!tracer) {\n    return func();\n  }\n  return tracer.withActiveSpan(name, optionsOrFn, contextOrFn, func);\n}\nexport {\n  getTracer,\n  shutdownTracers,\n  withActiveSpan\n};\n", "import {\n  BlobsInternalError,\n  Client,\n  MissingBlobsEnvironmentError,\n  REGION_AUTO,\n  collectIterator,\n  getClientOptions,\n  getEnvironmentContext,\n  getMetadataFromResponse,\n  setEnvironmentContext\n} from \"./chunk-HN33TXZT.js\";\n\n// src/lambda_compat.ts\nimport { base64Decode } from \"@netlify/runtime-utils\";\nvar connectLambda = (event) => {\n  const rawData = base64Decode(event.blobs);\n  const data = JSON.parse(rawData);\n  const environmentContext = {\n    deployID: event.headers[\"x-nf-deploy-id\"],\n    edgeURL: data.url,\n    siteID: event.headers[\"x-nf-site-id\"],\n    token: data.token\n  };\n  setEnvironmentContext(environmentContext);\n};\n\n// src/store.ts\nimport { getTracer, withActiveSpan } from \"@netlify/otel\";\nvar DEPLOY_STORE_PREFIX = \"deploy:\";\nvar LEGACY_STORE_INTERNAL_PREFIX = \"netlify-internal/legacy-namespace/\";\nvar SITE_STORE_PREFIX = \"site:\";\nvar STATUS_OK = 200;\nvar STATUS_PRE_CONDITION_FAILED = 412;\nvar Store = class _Store {\n  constructor(options) {\n    this.client = options.client;\n    if (\"deployID\" in options) {\n      _Store.validateDeployID(options.deployID);\n      let name = DEPLOY_STORE_PREFIX + options.deployID;\n      if (options.name) {\n        name += `:${options.name}`;\n      }\n      this.name = name;\n    } else if (options.name.startsWith(LEGACY_STORE_INTERNAL_PREFIX)) {\n      const storeName = options.name.slice(LEGACY_STORE_INTERNAL_PREFIX.length);\n      _Store.validateStoreName(storeName);\n      this.name = storeName;\n    } else {\n      _Store.validateStoreName(options.name);\n      this.name = SITE_STORE_PREFIX + options.name;\n    }\n  }\n  async delete(key) {\n    const res = await this.client.makeRequest({ key, method: \"delete\" /* DELETE */, storeName: this.name });\n    if (![200, 204, 404].includes(res.status)) {\n      throw new BlobsInternalError(res);\n    }\n  }\n  async deleteAll() {\n    const res = await this.client.makeRequest({ method: \"delete\" /* DELETE */, storeName: this.name });\n    if (res.status !== 200) {\n      throw new BlobsInternalError(res);\n    }\n    const data = await res.json();\n    if (typeof data.blobs_deleted !== \"number\") {\n      throw new BlobsInternalError(res);\n    }\n    return {\n      deletedBlobs: data.blobs_deleted\n    };\n  }\n  async get(key, options) {\n    return withActiveSpan(getTracer(), \"blobs.get\", async (span) => {\n      const { consistency, type } = options ?? {};\n      span?.setAttributes({\n        \"blobs.store\": this.name,\n        \"blobs.key\": key,\n        \"blobs.type\": type,\n        \"blobs.method\": \"GET\",\n        \"blobs.consistency\": consistency\n      });\n      const res = await this.client.makeRequest({\n        consistency,\n        key,\n        method: \"get\" /* GET */,\n        storeName: this.name\n      });\n      span?.setAttributes({\n        \"blobs.response.body.size\": res.headers.get(\"content-length\") ?? void 0,\n        \"blobs.response.status\": res.status\n      });\n      if (res.status === 404) {\n        return null;\n      }\n      if (res.status !== 200) {\n        throw new BlobsInternalError(res);\n      }\n      if (type === void 0 || type === \"text\") {\n        return res.text();\n      }\n      if (type === \"arrayBuffer\") {\n        return res.arrayBuffer();\n      }\n      if (type === \"blob\") {\n        return res.blob();\n      }\n      if (type === \"json\") {\n        return res.json();\n      }\n      if (type === \"stream\") {\n        return res.body;\n      }\n      throw new BlobsInternalError(res);\n    });\n  }\n  async getMetadata(key, { consistency } = {}) {\n    return withActiveSpan(getTracer(), \"blobs.getMetadata\", async (span) => {\n      span?.setAttributes({\n        \"blobs.store\": this.name,\n        \"blobs.key\": key,\n        \"blobs.method\": \"HEAD\",\n        \"blobs.consistency\": consistency\n      });\n      const res = await this.client.makeRequest({ consistency, key, method: \"head\" /* HEAD */, storeName: this.name });\n      span?.setAttributes({\n        \"blobs.response.status\": res.status\n      });\n      if (res.status === 404) {\n        return null;\n      }\n      if (res.status !== 200 && res.status !== 304) {\n        throw new BlobsInternalError(res);\n      }\n      const etag = res?.headers.get(\"etag\") ?? void 0;\n      const metadata = getMetadataFromResponse(res);\n      const result = {\n        etag,\n        metadata\n      };\n      return result;\n    });\n  }\n  async getWithMetadata(key, options) {\n    return withActiveSpan(getTracer(), \"blobs.getWithMetadata\", async (span) => {\n      const { consistency, etag: requestETag, type } = options ?? {};\n      const headers = requestETag ? { \"if-none-match\": requestETag } : void 0;\n      span?.setAttributes({\n        \"blobs.store\": this.name,\n        \"blobs.key\": key,\n        \"blobs.method\": \"GET\",\n        \"blobs.consistency\": options?.consistency,\n        \"blobs.type\": type,\n        \"blobs.request.etag\": requestETag\n      });\n      const res = await this.client.makeRequest({\n        consistency,\n        headers,\n        key,\n        method: \"get\" /* GET */,\n        storeName: this.name\n      });\n      const responseETag = res?.headers.get(\"etag\") ?? void 0;\n      span?.setAttributes({\n        \"blobs.response.body.size\": res.headers.get(\"content-length\") ?? void 0,\n        \"blobs.response.etag\": responseETag,\n        \"blobs.response.status\": res.status\n      });\n      if (res.status === 404) {\n        return null;\n      }\n      if (res.status !== 200 && res.status !== 304) {\n        throw new BlobsInternalError(res);\n      }\n      const metadata = getMetadataFromResponse(res);\n      const result = {\n        etag: responseETag,\n        metadata\n      };\n      if (res.status === 304 && requestETag) {\n        return { data: null, ...result };\n      }\n      if (type === void 0 || type === \"text\") {\n        return { data: await res.text(), ...result };\n      }\n      if (type === \"arrayBuffer\") {\n        return { data: await res.arrayBuffer(), ...result };\n      }\n      if (type === \"blob\") {\n        return { data: await res.blob(), ...result };\n      }\n      if (type === \"json\") {\n        return { data: await res.json(), ...result };\n      }\n      if (type === \"stream\") {\n        return { data: res.body, ...result };\n      }\n      throw new Error(`Invalid 'type' property: ${type}. Expected: arrayBuffer, blob, json, stream, or text.`);\n    });\n  }\n  list(options = {}) {\n    return withActiveSpan(getTracer(), \"blobs.list\", (span) => {\n      span?.setAttributes({\n        \"blobs.store\": this.name,\n        \"blobs.method\": \"GET\",\n        \"blobs.list.paginate\": options.paginate ?? false\n      });\n      const iterator = this.getListIterator(options);\n      if (options.paginate) {\n        return iterator;\n      }\n      return collectIterator(iterator).then(\n        (items) => items.reduce(\n          (acc, item) => ({\n            blobs: [...acc.blobs, ...item.blobs],\n            directories: [...acc.directories, ...item.directories]\n          }),\n          { blobs: [], directories: [] }\n        )\n      );\n    });\n  }\n  async set(key, data, options = {}) {\n    return withActiveSpan(getTracer(), \"blobs.set\", async (span) => {\n      span?.setAttributes({\n        \"blobs.store\": this.name,\n        \"blobs.key\": key,\n        \"blobs.method\": \"PUT\",\n        \"blobs.data.size\": typeof data == \"string\" ? data.length : data instanceof Blob ? data.size : data.byteLength,\n        \"blobs.data.type\": typeof data == \"string\" ? \"string\" : data instanceof Blob ? \"blob\" : \"arrayBuffer\",\n        \"blobs.atomic\": Boolean(options.onlyIfMatch ?? options.onlyIfNew)\n      });\n      _Store.validateKey(key);\n      const conditions = _Store.getConditions(options);\n      const res = await this.client.makeRequest({\n        conditions,\n        body: data,\n        key,\n        metadata: options.metadata,\n        method: \"put\" /* PUT */,\n        storeName: this.name\n      });\n      const etag = res.headers.get(\"etag\") ?? \"\";\n      span?.setAttributes({\n        \"blobs.response.etag\": etag,\n        \"blobs.response.status\": res.status\n      });\n      if (conditions) {\n        return res.status === STATUS_PRE_CONDITION_FAILED ? { modified: false } : { etag, modified: true };\n      }\n      if (res.status === STATUS_OK) {\n        return {\n          etag,\n          modified: true\n        };\n      }\n      throw new BlobsInternalError(res);\n    });\n  }\n  async setJSON(key, data, options = {}) {\n    return withActiveSpan(getTracer(), \"blobs.setJSON\", async (span) => {\n      span?.setAttributes({\n        \"blobs.store\": this.name,\n        \"blobs.key\": key,\n        \"blobs.method\": \"PUT\",\n        \"blobs.data.type\": \"json\"\n      });\n      _Store.validateKey(key);\n      const conditions = _Store.getConditions(options);\n      const payload = JSON.stringify(data);\n      const headers = {\n        \"content-type\": \"application/json\"\n      };\n      const res = await this.client.makeRequest({\n        ...conditions,\n        body: payload,\n        headers,\n        key,\n        metadata: options.metadata,\n        method: \"put\" /* PUT */,\n        storeName: this.name\n      });\n      const etag = res.headers.get(\"etag\") ?? \"\";\n      span?.setAttributes({\n        \"blobs.response.etag\": etag,\n        \"blobs.response.status\": res.status\n      });\n      if (conditions) {\n        return res.status === STATUS_PRE_CONDITION_FAILED ? { modified: false } : { etag, modified: true };\n      }\n      if (res.status === STATUS_OK) {\n        return {\n          etag,\n          modified: true\n        };\n      }\n      throw new BlobsInternalError(res);\n    });\n  }\n  static formatListResultBlob(result) {\n    if (!result.key) {\n      return null;\n    }\n    return {\n      etag: result.etag,\n      key: result.key\n    };\n  }\n  static getConditions(options) {\n    if (\"onlyIfMatch\" in options && \"onlyIfNew\" in options) {\n      throw new Error(\n        `The 'onlyIfMatch' and 'onlyIfNew' options are mutually exclusive. Using 'onlyIfMatch' will make the write succeed only if there is an entry for the key with the given content, while 'onlyIfNew' will make the write succeed only if there is no entry for the key.`\n      );\n    }\n    if (\"onlyIfMatch\" in options && options.onlyIfMatch) {\n      if (typeof options.onlyIfMatch !== \"string\") {\n        throw new Error(`The 'onlyIfMatch' property expects a string representing an ETag.`);\n      }\n      return {\n        onlyIfMatch: options.onlyIfMatch\n      };\n    }\n    if (\"onlyIfNew\" in options && options.onlyIfNew) {\n      if (typeof options.onlyIfNew !== \"boolean\") {\n        throw new Error(\n          `The 'onlyIfNew' property expects a boolean indicating whether the write should fail if an entry for the key already exists.`\n        );\n      }\n      return {\n        onlyIfNew: true\n      };\n    }\n  }\n  static validateKey(key) {\n    if (key === \"\") {\n      throw new Error(\"Blob key must not be empty.\");\n    }\n    if (key.startsWith(\"/\") || key.startsWith(\"%2F\")) {\n      throw new Error(\"Blob key must not start with forward slash (/).\");\n    }\n    if (new TextEncoder().encode(key).length > 600) {\n      throw new Error(\n        \"Blob key must be a sequence of Unicode characters whose UTF-8 encoding is at most 600 bytes long.\"\n      );\n    }\n  }\n  static validateDeployID(deployID) {\n    if (!/^\\w{1,24}$/.test(deployID)) {\n      throw new Error(`'${deployID}' is not a valid Netlify deploy ID.`);\n    }\n  }\n  static validateStoreName(name) {\n    if (name.includes(\"/\") || name.includes(\"%2F\")) {\n      throw new Error(\"Store name must not contain forward slashes (/).\");\n    }\n    if (new TextEncoder().encode(name).length > 64) {\n      throw new Error(\n        \"Store name must be a sequence of Unicode characters whose UTF-8 encoding is at most 64 bytes long.\"\n      );\n    }\n  }\n  getListIterator(options) {\n    const { client, name: storeName } = this;\n    const parameters = {};\n    if (options?.prefix) {\n      parameters.prefix = options.prefix;\n    }\n    if (options?.directories) {\n      parameters.directories = \"true\";\n    }\n    return {\n      [Symbol.asyncIterator]() {\n        let currentCursor = null;\n        let done = false;\n        return {\n          async next() {\n            return withActiveSpan(getTracer(), \"blobs.list.next\", async (span) => {\n              span?.setAttributes({\n                \"blobs.store\": storeName,\n                \"blobs.method\": \"GET\",\n                \"blobs.list.paginate\": options?.paginate ?? false,\n                \"blobs.list.done\": done,\n                \"blobs.list.cursor\": currentCursor ?? void 0\n              });\n              if (done) {\n                return { done: true, value: void 0 };\n              }\n              const nextParameters = { ...parameters };\n              if (currentCursor !== null) {\n                nextParameters.cursor = currentCursor;\n              }\n              const res = await client.makeRequest({\n                method: \"get\" /* GET */,\n                parameters: nextParameters,\n                storeName\n              });\n              span?.setAttributes({\n                \"blobs.response.status\": res.status\n              });\n              let blobs = [];\n              let directories = [];\n              if (![200, 204, 404].includes(res.status)) {\n                throw new BlobsInternalError(res);\n              }\n              if (res.status === 404) {\n                done = true;\n              } else {\n                const page = await res.json();\n                if (page.next_cursor) {\n                  currentCursor = page.next_cursor;\n                } else {\n                  done = true;\n                }\n                blobs = (page.blobs ?? []).map(_Store.formatListResultBlob).filter(Boolean);\n                directories = page.directories ?? [];\n              }\n              return {\n                done: false,\n                value: {\n                  blobs,\n                  directories\n                }\n              };\n            });\n          }\n        };\n      }\n    };\n  }\n};\n\n// src/store_factory.ts\nvar getDeployStore = (input = {}) => {\n  const context = getEnvironmentContext();\n  const options = typeof input === \"string\" ? { name: input } : input;\n  const deployID = options.deployID ?? context.deployID;\n  if (!deployID) {\n    throw new MissingBlobsEnvironmentError([\"deployID\"]);\n  }\n  const clientOptions = getClientOptions(options, context);\n  if (!clientOptions.region) {\n    if (clientOptions.edgeURL || clientOptions.uncachedEdgeURL) {\n      if (!context.primaryRegion) {\n        throw new Error(\n          \"When accessing a deploy store, the Netlify Blobs client needs to be configured with a region, and one was not found in the environment. To manually set the region, set the `region` property in the `getDeployStore` options. If you are using the Netlify CLI, you may have an outdated version; run `npm install -g netlify-cli@latest` to update and try again.\"\n        );\n      }\n      clientOptions.region = context.primaryRegion;\n    } else {\n      clientOptions.region = REGION_AUTO;\n    }\n  }\n  const client = new Client(clientOptions);\n  return new Store({ client, deployID, name: options.name });\n};\nvar getStore = (input) => {\n  if (typeof input === \"string\") {\n    const clientOptions = getClientOptions({});\n    const client = new Client(clientOptions);\n    return new Store({ client, name: input });\n  }\n  if (typeof input?.name === \"string\" && typeof input?.siteID === \"string\" && typeof input?.token === \"string\") {\n    const { name, siteID, token } = input;\n    const clientOptions = getClientOptions(input, { siteID, token });\n    if (!name || !siteID || !token) {\n      throw new MissingBlobsEnvironmentError([\"name\", \"siteID\", \"token\"]);\n    }\n    const client = new Client(clientOptions);\n    return new Store({ client, name });\n  }\n  if (typeof input?.name === \"string\") {\n    const { name } = input;\n    const clientOptions = getClientOptions(input);\n    if (!name) {\n      throw new MissingBlobsEnvironmentError([\"name\"]);\n    }\n    const client = new Client(clientOptions);\n    return new Store({ client, name });\n  }\n  if (typeof input?.deployID === \"string\") {\n    const clientOptions = getClientOptions(input);\n    const { deployID } = input;\n    if (!deployID) {\n      throw new MissingBlobsEnvironmentError([\"deployID\"]);\n    }\n    const client = new Client(clientOptions);\n    return new Store({ client, deployID });\n  }\n  throw new Error(\n    \"The `getStore` method requires the name of the store as a string or as the `name` property of an options object\"\n  );\n};\n\n// src/store_list.ts\nfunction listStores(options = {}) {\n  const context = getEnvironmentContext();\n  const clientOptions = getClientOptions(options, context);\n  const client = new Client(clientOptions);\n  const iterator = getListIterator(client, SITE_STORE_PREFIX);\n  if (options.paginate) {\n    return iterator;\n  }\n  return collectIterator(iterator).then((results) => ({ stores: results.flatMap((page) => page.stores) }));\n}\nvar formatListStoreResponse = (stores) => stores.filter((store) => !store.startsWith(DEPLOY_STORE_PREFIX)).map((store) => store.startsWith(SITE_STORE_PREFIX) ? store.slice(SITE_STORE_PREFIX.length) : store);\nvar getListIterator = (client, prefix) => {\n  const parameters = {\n    prefix\n  };\n  return {\n    [Symbol.asyncIterator]() {\n      let currentCursor = null;\n      let done = false;\n      return {\n        async next() {\n          if (done) {\n            return { done: true, value: void 0 };\n          }\n          const nextParameters = { ...parameters };\n          if (currentCursor !== null) {\n            nextParameters.cursor = currentCursor;\n          }\n          const res = await client.makeRequest({\n            method: \"get\" /* GET */,\n            parameters: nextParameters\n          });\n          if (res.status === 404) {\n            return { done: true, value: void 0 };\n          }\n          const page = await res.json();\n          if (page.next_cursor) {\n            currentCursor = page.next_cursor;\n          } else {\n            done = true;\n          }\n          return {\n            done: false,\n            value: {\n              ...page,\n              stores: formatListStoreResponse(page.stores)\n            }\n          };\n        }\n      };\n    }\n  };\n};\nexport {\n  connectLambda,\n  getDeployStore,\n  getStore,\n  listStores,\n  setEnvironmentContext\n};\n", "import { getStore } from '@netlify/blobs';\r\n\r\nexport type TelemetryCategory = 'webhook' | 'router' | 'dispatcher' | 'security' | 'performance' | 'error';\r\n\r\nexport interface TelemetryEvent {\r\n  timestamp: string;\r\n  category: TelemetryCategory;\r\n  event: string;\r\n  data: Record<string, any>;\r\n}\r\n\r\nexport class TelemetryLogger {\r\n  private events: TelemetryEvent[] = [];\r\n  private store = getStore('webhook-telemetry');\r\n\r\n  log(category: TelemetryCategory, event: string, data: Record<string, any> = {}) {\r\n    const telemetryEvent: TelemetryEvent = { timestamp: new Date().toISOString(), category, event, data };\r\n    this.events.push(telemetryEvent);\r\n    if (process.env.NODE_ENV === 'development') console.log(`[${category}] ${event}:`, data);\r\n    this.persistAsync(telemetryEvent);\r\n  }\r\n\r\n  private async persistAsync(event: TelemetryEvent) {\r\n    try {\r\n      const key = `events/${new Date().toISOString().split('T')[0]}/${event.timestamp}`;\r\n      await this.store.set(key, JSON.stringify(event));\r\n    } catch (error) {\r\n      console.error('Failed to persist telemetry:', error);\r\n    }\r\n  }\r\n\r\n  getEvents(): TelemetryEvent[] {\r\n    return [...this.events];\r\n  }\r\n\r\n  async getHistoricalEvents(days: number = 7): Promise<TelemetryEvent[]> {\r\n    const events: TelemetryEvent[] = [];\r\n    const startDate = new Date();\r\n    startDate.setDate(startDate.getDate() - days);\r\n\r\n    try {\r\n      const { blobs } = await this.store.list({ prefix: 'events/' });\r\n      for (const blob of blobs) {\r\n        \r\n      }\r\n    } catch (error) {\r\n      console.error('Failed to retrieve historical events:', error);\r\n    }\r\n\r\n    return events.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());\r\n  }\r\n}\r\n\r\n"],
  "mappings": "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",
  "names": []
}
